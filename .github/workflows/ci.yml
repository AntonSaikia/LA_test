name: CI/CD Pipeline

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
  workflow_dispatch: # Allow manual triggering

jobs:
  build: # Renamed from 'test' to 'build' for clarity, as it builds and tests
    runs-on: ubuntu-latest # Using ubuntu-latest as it's generally stable

    services:
      # MySQL service: Will be accessible at hostname 'mysql' from other services or 'host.docker.internal' from steps
      mysql:
        image: mysql:8.0 # Sticking to 8.0 as per your previous working version
        env:
          MYSQL_ROOT_PASSWORD: ${{ secrets.MYSQL_ROOT_PASSWORD }} # Use secrets for passwords!
          MYSQL_DATABASE: eng_deu_vocab # Use your correct database name
        ports:
          - 3306:3306
        options: >- # Correct syntax for multi-line options
          --health-cmd "mysqladmin ping -h 127.0.0.1 -p${{ secrets.MYSQL_ROOT_PASSWORD }}"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 10

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'
          cache: 'maven'

      - name: Install Playwright Browsers
        # Run from the correct directory for Playwright tests
        run: mvn -f tests/java/pom.xml exec:java -e -Dexec.mainClass=com.microsoft.playwright.CLI -Dexec.args="install --with-deps"

      - name: Wait for MySQL service
        run: |
          echo "Waiting for MySQL service to be ready..."
          for i in $(seq 1 60); do # Up to 60 seconds
            # Use 'nc -z' to check if the port is open on the service host
            # 'mysql' is the hostname for the mysql service defined in 'services'
            if nc -z mysql 3306; then
              echo "MySQL is up!"
              break
            fi
            echo -n "."
            sleep 1
          done
          echo "" # Newline after dots
          # Fail if MySQL didn't start within the timeout
          nc -z mysql 3306 || { echo "MySQL service failed to start!"; exit 1; }


      # --- Database Schema and Data Preparation (after MySQL is up) ---
      # Execute schema.sql and seed_data.sql directly against the MySQL service
      - name: Prepare Database Schema and Data
        run: |
          # The 'mysql' hostname works directly in the job steps too, as it's part of the same network
          echo "Applying database schema..."
          mysql -h mysql -uroot -p"${{ secrets.MYSQL_ROOT_PASSWORD }}" < database/schema.sql
          echo "Seeding database with initial data..."
          mysql -h mysql -uroot -p"${{ secrets.MYSQL_ROOT_PASSWORD }}" eng_deu_vocab < database/seed_data.sql
          echo "Database prepared."

      # --- Start PHP-Apache container (similar to your previous working version) ---
      # This runs the PHP-Apache container as a sibling to the main job,
      # and uses host.docker.internal to connect to the MySQL service on the host.
      - name: Start PHP-Apache container
        run: |
          echo "Starting PHP-Apache container..."
          docker run -d --name php-apache \
            -p 80:80 \
            -e DB_HOST=host.docker.internal \
            -e DB_USER=root \
            -e DB_PASSWORD=${{ secrets.MYSQL_ROOT_PASSWORD }} \
            -e DB_NAME=eng_deu_vocab \
            -v ${{ github.workspace }}/backend/api:/var/www/html/api \
            -v ${{ github.workspace }}/frontend:/var/www/html/frontend \
            php:8.2-apache
          echo "PHP-Apache container started."

      - name: Wait for PHP-Apache to be ready
        run: |
          echo "Waiting for PHP-Apache to be reachable via HTTP on localhost:80..."
          for i in $(seq 1 60); do
            # Use curl to check a known API endpoint for a 200 OK
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" http://localhost/api/get_words.php)
            if [ "$HTTP_CODE" -eq 200 ]; then
              echo "PHP-Apache /api/get_words.php is reachable ($HTTP_CODE)."
              # Optionally, check for content in the response too, if you want
              RESPONSE=$(curl -s http://localhost/api/get_words.php)
              if echo "$RESPONSE" | grep -q "Hello"; then
                echo "API returned expected content."
                break
              fi
            fi
            echo -n "."
            sleep 1
          done
          echo "" # Newline after dots
          curl --fail http://localhost/api/get_words.php || { echo "PHP-Apache API failed to respond with expected content!"; exit 1; }
          echo "All services are ready for Playwright tests."


      - name: Run Playwright Tests
        run: |
          # Assuming FrontendTests.java uses http://localhost/frontend/ and http://localhost/api/
          mvn -f tests/java/pom.xml test \
            -Dfrontend.base.path=/frontend/ \
            -Dapi.base.path=/api/

      # --- Upload Playwright Traces and Test Reports ---
      - name: Upload Playwright traces
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-traces
          path: trace-*.zip
          retention-days: 7

      - name: Upload Test Reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-test-results
          path: tests/java/target/surefire-reports/ # Collect Surefire reports

      # --- Optional: Collect and Upload Docker Container Logs ---
      # Useful for debugging if tests fail, but services appear "ready"
      - name: Collect Docker container logs
        if: always()
        run: |
          echo "Collecting logs for PHP-Apache container..."
          docker logs php-apache > php-apache-logs.txt || echo "php-apache container logs not found."
          echo "Collecting logs for MySQL service container..."
          # Find the actual service container name, which often includes a random suffix
          MYSQL_SVC_CONTAINER_ID=$(docker ps -aq --filter "name=build_mysql")
          if [ -n "$MYSQL_SVC_CONTAINER_ID" ]; then
            docker logs $MYSQL_SVC_CONTAINER_ID > mysql-service-logs.txt
          else
            echo "MySQL service container not found for log collection."
          fi
          echo "Container logs collected."

      - name: Upload collected logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: container-logs
          path: |
            php-apache-logs.txt
            mysql-service-logs.txt
          retention-days: 7